local boxes          = {}
local box_group      = -1
local ray_start      = vmath.vector3(0, 0, 0)
local ray_end        = vmath.vector3(365, 370, 0)
local query_result   = {}
local result_count   = 0
local collision_bits = {
    PLAYER = 1,          -- (2^0)
    ENEMY  = 2,          -- (2^1)
    ITEM   = 4,          -- (2^2)
    ALL    = bit.bnot(0) -- -1 for all results
}
local mask_bits      = bit.bor(collision_bits.ENEMY, collision_bits.ITEM)

local function add_box(box_position, box_type, is_static, category, get_world_position)
    category = category and category or nil
    get_world_position = get_world_position and get_world_position or nil

    local box_id = factory.create("/factory#box", box_position)
    local sprite_url = msg.url(nil, box_id, "sprite")

    if box_type == 1 then
        sprite.play_flipbook(sprite_url, "60x30")
    end


    local box_label = msg.url(nil, box_id, "label")
    local sprite_size = go.get(sprite_url, "size")

    -- Insert AABB into the group.
    local box_aabb_id = -1


    if is_static then -- If not moving gameobject
        box_aabb_id = daabbcc.insert_aabb(box_group, box_position.x, box_position.y, sprite_size.x, sprite_size.y, category)
    else
        box_aabb_id = daabbcc.insert_gameobject(box_group, box_id, sprite_size.x, sprite_size.y, category, get_world_position)
    end

    label.set_text(box_label, box_aabb_id .. "\n" .. category)
    local t = { position = box_position, id = box_id, sprite_url = sprite_url, size = sprite_size, aabb_id = box_aabb_id }
    table.insert(boxes, t)
end


local world


local query_box
function init(self)
    -- msg.post("@render:", "use_camera_projection")
    msg.post(".", "acquire_input_focus")

    -- New group for AABBs.
    box_group = daabbcc.new_group()

    -- Insert AABB into the group.
    add_box(vmath.vector3(0, 0, 0), 0, true, collision_bits.PLAYER)
    add_box(vmath.vector3(0, 0, 0), 0, false, collision_bits.ALL)
    -- add_box(vmath.vector3(10, 10, 0), 1, true, collision_bits.PLAYER)


    --[[  query_box = factory.create("/factory#box", vmath.vector3(10, 10, 0))

    local result, count = daabbcc.query_aabb(box_group, 10, 10, 40,
        40, nil, true)

    print("count: ", count)
    if result then
        pprint(result)
    end]]
end

local res_pos

function update(self, dt)
    daabbcc.update_aabb(box_group, boxes[2].aabb_id, world.x, world.y, 40, 40)
    local result, count = daabbcc.query_id(box_group, boxes[2].aabb_id, nil, true)



    -- TODO DO UPDATE HERE

    if result then
        pprint(result)
        for i = 1, count do
            local offset_x = result[i].normal_x * result[i].depth
            local offset_y = result[i].normal_y * result[i].depth

            world = world + vmath.vector3(offset_x, offset_y, 0)
        end
    end

    go.set_position(world, boxes[2].id)
end

local DISPLAY_WIDTH = sys.get_config_int("display.width")
local DISPLAY_HEIGHT = sys.get_config_int("display.height")


local function screen_to_world(x, y, z, camera)
    local projection = go.get(camera, "projection")
    local view = go.get(camera, "view")
    local w, h = window.get_size()
    -- The window.get_size() function will return the scaled window size,
    -- ie taking into account display scaling (Retina screens on macOS for
    -- instance). We need to adjust for display scaling in our calculation.
    w = w / (w / DISPLAY_WIDTH)
    h = h / (h / DISPLAY_HEIGHT)

    -- https://defold.com/manuals/camera/#converting-mouse-to-world-coordinates
    local inv = vmath.inv(projection * view)
    x = (2 * x / w) - 1
    y = (2 * y / h) - 1
    z = (2 * z) - 1
    local x1 = x * inv.m00 + y * inv.m01 + z * inv.m02 + inv.m03
    local y1 = x * inv.m10 + y * inv.m11 + z * inv.m12 + inv.m13
    local z1 = x * inv.m20 + y * inv.m21 + z * inv.m22 + inv.m23
    return x1, y1, z1
end


function on_input(self, action_id, action)
    ray_end.x = action.x
    ray_end.y = action.y
    local worldx, worldy = screen_to_world(action.x, action.y, 0, "/camera#camera")
    world = vmath.vector3(worldx, worldy, 0)
end
